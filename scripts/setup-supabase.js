#!/usr/bin/env node

/**
 * StoreForge AI - Automated Supabase Setup Script
 * This script creates a new Supabase project and configures the database schema
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const readline = require('readline');

// Colors for console output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m'
};

const log = {
  info: (msg) => console.log(`${colors.blue}‚Ñπ${colors.reset} ${msg}`),
  success: (msg) => console.log(`${colors.green}‚úÖ${colors.reset} ${msg}`),
  warning: (msg) => console.log(`${colors.yellow}‚ö†${colors.reset} ${msg}`),
  error: (msg) => console.log(`${colors.red}‚ùå${colors.reset} ${msg}`),
  title: (msg) => console.log(`\n${colors.cyan}${colors.bright}üöÄ ${msg}${colors.reset}\n`)
};

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

function askQuestion(question) {
  return new Promise((resolve) => {
    rl.question(question, resolve);
  });
}

function generateRandomPassword(length = 16) {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';
  let password = '';
  for (let i = 0; i < length; i++) {
    password += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return password;
}

function updateEnvFile(supabaseUrl, anonKey, serviceKey) {
  const envPath = path.join(__dirname, '..', '.env.local');
  let envContent = '';
  
  if (fs.existsSync(envPath)) {
    envContent = fs.readFileSync(envPath, 'utf8');
  }
  
  // Update or add Supabase variables
  const updates = {
    'NEXT_PUBLIC_SUPABASE_URL': supabaseUrl,
    'NEXT_PUBLIC_SUPABASE_ANON_KEY': anonKey,
    'SUPABASE_SERVICE_ROLE_KEY': serviceKey
  };
  
  Object.entries(updates).forEach(([key, value]) => {
    const regex = new RegExp(`^${key}=.*$`, 'm');
    if (regex.test(envContent)) {
      envContent = envContent.replace(regex, `${key}=${value}`);
    } else {
      envContent += `\n${key}=${value}`;
    }
  });
  
  fs.writeFileSync(envPath, envContent.trim() + '\n');
  log.success('Updated .env.local with Supabase credentials');
}

function createSupabaseProject() {
  return `
-- StoreForge AI Database Schema
-- Auto-generated by setup script

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Users table
CREATE TABLE IF NOT EXISTS users (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  name VARCHAR(255),
  plan VARCHAR(50) DEFAULT 'starter',
  stores_created INTEGER DEFAULT 0,
  stores_limit INTEGER DEFAULT 3,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Stores table
CREATE TABLE IF NOT EXISTS stores (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  name VARCHAR(255) NOT NULL,
  product_url TEXT NOT NULL,
  platform VARCHAR(50) NOT NULL CHECK (platform IN ('shopify', 'woocommerce')),
  domain VARCHAR(255),
  status VARCHAR(50) DEFAULT 'building' CHECK (status IN ('building', 'deployed', 'failed', 'pending')),
  success_score INTEGER CHECK (success_score >= 0 AND success_score <= 100),
  market_research JSONB DEFAULT '{}',
  content JSONB DEFAULT '{}',
  images JSONB DEFAULT '{}',
  platform_data JSONB DEFAULT '{}',
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Payments table
CREATE TABLE IF NOT EXISTS payments (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  ziina_payment_id VARCHAR(255),
  amount DECIMAL(10,2) NOT NULL CHECK (amount > 0),
  currency VARCHAR(3) DEFAULT 'AED' CHECK (currency IN ('AED', 'USD', 'EUR')),
  status VARCHAR(50) NOT NULL CHECK (status IN ('pending', 'processing', 'completed', 'failed', 'cancelled', 'expired')),
  customer_email VARCHAR(255) NOT NULL,
  customer_name VARCHAR(255) NOT NULL,
  product_type VARCHAR(100) NOT NULL,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Subscriptions table
CREATE TABLE IF NOT EXISTS subscriptions (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  ziina_subscription_id VARCHAR(255),
  customer_email VARCHAR(255) NOT NULL,
  status VARCHAR(50) NOT NULL CHECK (status IN ('active', 'cancelled', 'expired', 'pending')),
  plan_type VARCHAR(50) NOT NULL CHECK (plan_type IN ('starter', 'pro', 'enterprise')),
  amount DECIMAL(10,2) NOT NULL CHECK (amount > 0),
  currency VARCHAR(3) DEFAULT 'AED' CHECK (currency IN ('AED', 'USD', 'EUR')),
  start_date TIMESTAMP WITH TIME ZONE NOT NULL,
  end_date TIMESTAMP WITH TIME ZONE,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
CREATE INDEX IF NOT EXISTS idx_stores_user_id ON stores(user_id);
CREATE INDEX IF NOT EXISTS idx_stores_status ON stores(status);
CREATE INDEX IF NOT EXISTS idx_payments_user_id ON payments(user_id);
CREATE INDEX IF NOT EXISTS idx_payments_status ON payments(status);
CREATE INDEX IF NOT EXISTS idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX IF NOT EXISTS idx_subscriptions_status ON subscriptions(status);

-- Enable Row Level Security
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE stores ENABLE ROW LEVEL SECURITY;
ALTER TABLE payments ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;

-- Create RLS policies

-- Users policies
CREATE POLICY "Users can view own data" ON users
  FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Users can update own data" ON users
  FOR UPDATE USING (auth.uid() = id);

CREATE POLICY "Users can insert own data" ON users
  FOR INSERT WITH CHECK (auth.uid() = id);

-- Stores policies
CREATE POLICY "Users can view own stores" ON stores
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can create stores" ON stores
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own stores" ON stores
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own stores" ON stores
  FOR DELETE USING (auth.uid() = user_id);

-- Payments policies
CREATE POLICY "Users can view own payments" ON payments
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can create payments" ON payments
  FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Subscriptions policies
CREATE POLICY "Users can view own subscriptions" ON subscriptions
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can create subscriptions" ON subscriptions
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own subscriptions" ON subscriptions
  FOR UPDATE USING (auth.uid() = user_id);

-- Create functions for automatic timestamp updates
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create triggers for automatic timestamp updates
CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_stores_updated_at BEFORE UPDATE ON stores
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_payments_updated_at BEFORE UPDATE ON payments
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at BEFORE UPDATE ON subscriptions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Insert sample data for testing (optional)
INSERT INTO users (id, email, name, plan, stores_limit) VALUES
  ('00000000-0000-0000-0000-000000000001', 'demo@storeforge.ai', 'Demo User', 'pro', 10)
ON CONFLICT (email) DO NOTHING;

-- Success message
SELECT 'StoreForge AI database schema created successfully!' as message;
`;
}

async function main() {
  try {
    log.title('StoreForge AI - Supabase Setup Wizard');
    
    log.info('This script will help you set up Supabase for StoreForge AI');
    log.info('You will need to create a Supabase account if you don\'t have one');
    
    const proceed = await askQuestion('\nDo you want to continue? (y/n): ');
    if (proceed.toLowerCase() !== 'y' && proceed.toLowerCase() !== 'yes') {
      log.info('Setup cancelled');
      process.exit(0);
    }
    
    log.info('\nüìã Setup Steps:');
    log.info('1. Go to https://supabase.com');
    log.info('2. Sign up or sign in to your account');
    log.info('3. Create a new project');
    log.info('4. Copy the project URL and API keys');
    
    await askQuestion('\nPress Enter when you have created your Supabase project...');
    
    // Get Supabase credentials
    const supabaseUrl = await askQuestion('\nEnter your Supabase Project URL (https://xxx.supabase.co): ');
    const anonKey = await askQuestion('Enter your Supabase Anon Key: ');
    const serviceKey = await askQuestion('Enter your Supabase Service Role Key: ');
    
    // Validate inputs
    if (!supabaseUrl || !anonKey || !serviceKey) {
      log.error('All fields are required!');
      process.exit(1);
    }
    
    if (!supabaseUrl.includes('supabase.co')) {
      log.error('Invalid Supabase URL format');
      process.exit(1);
    }
    
    // Update environment file
    log.info('\nüîß Updating environment variables...');
    updateEnvFile(supabaseUrl, anonKey, serviceKey);
    
    // Create database schema file
    log.info('üìù Creating database schema...');
    const schemaContent = createSupabaseProject();
    const schemaPath = path.join(__dirname, '..', 'src', 'lib', 'supabase', 'setup-schema.sql');
    
    // Ensure directory exists
    const schemaDir = path.dirname(schemaPath);
    if (!fs.existsSync(schemaDir)) {
      fs.mkdirSync(schemaDir, { recursive: true });
    }
    
    fs.writeFileSync(schemaPath, schemaContent);
    log.success('Database schema file created at: src/lib/supabase/setup-schema.sql');
    
    log.info('\nüìä Next Steps:');
    log.info('1. Go to your Supabase dashboard');
    log.info('2. Navigate to SQL Editor');
    log.info('3. Copy and paste the schema from: src/lib/supabase/setup-schema.sql');
    log.info('4. Run the SQL to create all tables and policies');
    
    log.success('\nüéâ Supabase setup completed successfully!');
    log.info('Your StoreForge AI application is now ready to use Supabase!');
    
    // Create a quick test script
    const testScript = `
// Test Supabase connection
const { createClient } = require('@supabase/supabase-js');
require('dotenv').config({ path: '.env.local' });

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
);

async function testConnection() {
  try {
    const { data, error } = await supabase.from('users').select('count');
    if (error) throw error;
    console.log('‚úÖ Supabase connection successful!');
    console.log('Database is ready for StoreForge AI');
  } catch (error) {
    console.error('‚ùå Connection failed:', error.message);
  }
}

testConnection();
`;
    
    fs.writeFileSync(path.join(__dirname, 'test-supabase-connection.js'), testScript);
    log.info('\nüß™ Test script created: scripts/test-supabase-connection.js');
    log.info('Run "node scripts/test-supabase-connection.js" to test your connection');
    
  } catch (error) {
    log.error(`Setup failed: ${error.message}`);
    process.exit(1);
  } finally {
    rl.close();
  }
}

if (require.main === module) {
  main();
}

module.exports = { main };